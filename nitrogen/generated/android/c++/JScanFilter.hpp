///
/// JScanFilter.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "ScanFilter.hpp"

#include "AndroidScanMode.hpp"
#include "JAndroidScanMode.hpp"
#include <string>
#include <vector>

namespace margelo::nitro::co::zyke::ble {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "ScanFilter" and the the Kotlin data class "ScanFilter".
   */
  struct JScanFilter final: public jni::JavaClass<JScanFilter> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/co/zyke/ble/ScanFilter;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct ScanFilter by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    ScanFilter toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldServiceUUIDs = clazz->getField<jni::JArrayClass<jni::JString>>("serviceUUIDs");
      jni::local_ref<jni::JArrayClass<jni::JString>> serviceUUIDs = this->getFieldValue(fieldServiceUUIDs);
      static const auto fieldRssiThreshold = clazz->getField<double>("rssiThreshold");
      double rssiThreshold = this->getFieldValue(fieldRssiThreshold);
      static const auto fieldAllowDuplicates = clazz->getField<jboolean>("allowDuplicates");
      jboolean allowDuplicates = this->getFieldValue(fieldAllowDuplicates);
      static const auto fieldAndroidScanMode = clazz->getField<JAndroidScanMode>("androidScanMode");
      jni::local_ref<JAndroidScanMode> androidScanMode = this->getFieldValue(fieldAndroidScanMode);
      return ScanFilter(
        [&]() {
          size_t __size = serviceUUIDs->size();
          std::vector<std::string> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = serviceUUIDs->getElement(__i);
            __vector.push_back(__element->toStdString());
          }
          return __vector;
        }(),
        rssiThreshold,
        static_cast<bool>(allowDuplicates),
        androidScanMode->toCpp()
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JScanFilter::javaobject> fromCpp(const ScanFilter& value) {
      return newInstance(
        [&]() {
          size_t __size = value.serviceUUIDs.size();
          jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.serviceUUIDs[__i];
            __array->setElement(__i, *jni::make_jstring(__element));
          }
          return __array;
        }(),
        value.rssiThreshold,
        value.allowDuplicates,
        JAndroidScanMode::fromCpp(value.androidScanMode)
      );
    }
  };

} // namespace margelo::nitro::co::zyke::ble
